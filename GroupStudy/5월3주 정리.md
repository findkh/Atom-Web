## 1. SI(System Integration)
- 시스템을 구축하는 업무
정보시스템에 관한 기획에서부터 개발과 구축, 운영까지 모든 서비스를 제공하는 일을 하는 업체입니다.

## 2. 개발 프로세서? 
- 소프트웨어 생명 주기(SDLC; Software Development Life Cycle)
시스템의 요구분석, 설계, 구현, 테스트, 유지보수까지 전 공정을 체계화한 절차로 폭포수 모델, 프로토타이핑모델, 나선형 모델, 반복적 모델이 있습니다.  
폭포수모델 : 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어 가는 모델로 고전적인 개발방법론으로 요구사항 변경이 어렵습니다.  
프로토타이핑 모델 : 고객이 요구한 주요 기능을 프로토타입으로 구현하여 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델입니다.  
나선형 모델 : 시스템 개발 시 위험을 최소화하기 위해 점진적으로 개발해 가는 모델입니다.
반복적 모델 : 구축대상을 나누어 병렬적으로 개발 후 통합하거나 반복적으로 개발하여 점증 완성시키는  SDLC 모델입니다.

## 3. MVC2모델
- MVC2모델은 MVC1 모델의 입출력 데이터가공, 서비스 객체 호출 코드가 중복되는 문제를 해결하기 위해 등장하였습니다.
Controller는 클라이언트가 보낸 입력 데이터를 가공 및 검증하고 서비스 객체를 실행하며 출력 데이터를 준비하고 실행시킬 view 객체를 선정하기 떄문에 view는 온전히 출력할 데이터를 가공하는 일만 하게 됩니다.

## 4. 좋은 프로그램이란?
- 사용자 입장에서 누구나 쉽게 이해하고 사용할수 있어야하고 사용자의 목표가 정확히 반영되어야하며 쉽게 배울 수 있어야하며 사용자의 실수를 방지할 수 있도록 제작되어야 합니다. (직관성, 유효성, 학습성, 유연성)  UX
개발자 입장에서는 읽기 쉽고 이해하기 쉬워야하며 일관성이 있고 재사용이 가능하도록 모듈화가 되어있어야 합니다.

## 5. Call by value, Call by reference
- Call by value는 값을 복사하여 처리하기 때문에 원래의 값이 보존되지만 메모리 사용량이 늘어납니다. 자바의 원시타입(int, short, long, float, double, char, boolean)
Call by reference는 직접 참조를 하기 때문에 빠르지만 원래의 값이 영향을 받습니다. 

## 6. static의 의미
- static이라는 키워드를 사용하여 static 변수와 static 메소드를 만들 수 있고 이 둘을 합쳐 static 멤버(클래스 멤버)라고 합니다.
static멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버이기에 클래스 로더가 클래스를 로딩해서 메소드 영역에 적재할 때 클래스 별로 관리되기 때문에 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있습니다.

## 7.클래스, 객체, 인스턴스의 차이점
- 클래스란 객체를 정의하고 만들어 내기 위한 설계도 또는 틀을 말합니다. ex) 붕어빵 틀
- 객체란 클래스에 선언된 모양 그대로 생성된 실체를 말합니다. ex) 붕어빵
- 인스턴스란 클래스를 통해서 구현해야할 대상이 실제로 구현된 구체적인 실체를 말합니다. ex)팥 붕어빵, 슈크림붕어빵

## 8. 프레임워크
- 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게 일련의 협업화된 형태로 클래스를 제공하는 것입니다.

## 9. Java와 C의 차이
- C언어는 절차지향언어이기에 순차적으로 읽어가지만 자바는 설계적인 측면이 강조된 객체지향 언어입니다.
C언어가 상대적으로 빠르고, 유지보수가 어렵지만 자바는 문제가된 객체만 찾아 수정하면 되기 때문에 유지보수에 유리합니다.
C언어는 임베디드 또는 OS처럼 속도나 용량 등에서 최적화가 필요한 곳에서 주로 사용하고, 자바는 웹사이트나 운영체제와 상관업싱 실행되어야 하는 응용SW에서 사용됩니다.
C언어는 메모리를 직접 조절하여 메모리 낭비가 적지만 자바는 각각의 클래스로 인해 메모리 낭비가 높습니다.

## 10. 배열과 링크드리스트의 차이 
- 배열은 크기가 고정적이고 인덱스를 안다면 접근속도가 빠르지만 삽입 삭제 할 때 위치를 이동시키기 때문에 비효율적입니다.
링크드리스트는 크키가 동적으로 증가되며 배열에 비해 위를 하나하나 따라가기 때문에 느리지만 삽입 삭제시 연결되어 있는 위치에 접근하여 리스트만 추가하면 되기 때문에 배열에 비해 효율적입니다.

## 11. 인터프리터와 컴파일러의 차이
- 컴파일러는 전체 소스코드를 보고 명령어를 수집하여 재구성하지만 인터프리터는 소스코드 각 행을 연속적으로 분석하며 실행합니다.
인터프리터는 기계어로 번역하지하고 중간 형태로 변환시킨 후 실행하지만 컴파일러는 바로 기계어로 변환합니다.
인터프리터보다 컴파일러가 실행시간이 빠르지만, 컴파일러는 전체 소스코드를 변환한 후 에러를 보고하지만 인터프리터는 각 행을 실행하는 도중 에러가 보고되면 이후에 작성된 코드는 실행하지 않기 때문에 보안적인 관점에서 도움이 됩니다.
https://velog.io/@jaeyunn_15/OS-Compiler-vs-Interpreter

## 12. 자바 컴파일 도구
- JDK

## 13. sql 쿼리문 작성5개

## 14. 평균, join, 

## 15. 쉘스크립트 helloworld 출력
echo "Hello world"

## 16. 쉘스크립트 ip주소 명령
- ip config

---
## 17. 자바 언어, 장점
- 자바는 객체지향 프로그래밍언어 중 하나로 상속, 캡슐화, 다형성, 추상화의 특징이 있고 C언어와 다르게 JVM이 메모리 관리를 자동으로 해줍니다.
또한 CPU나 OS의 종류와 무관하게 동일하게 동작합니다.

## 18. stack, queue
- 스택은 책을 쌓는 것 처럼 차곡차곡 쌓아 올린 자료구조로 같은 구조와 같은 크기의 자료롤 정해진 방향으로 쌓을 수 있고 마지막에 삽입된 자료가 가장 먼저 삭제되는 특징을 가지고 있습니다.  
큐는 스택과 반대로 먼저 들어온 자료가 먼저 출력되는 방식을 갖고, 정해진 곳에서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서는 삽입작업이, 다른 끝에서는 삭제 작업이 이루어집니다.

## 19. 객체지향프로그래밍
- 프로그램 구현에 필요한 객체를 파악하고 그 역할이 무엇인지 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것입니다.
객체 지향 프로그래밍에서 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 프로그래밍입니다.

## 20. hashmap, hashtable, hashset 정의, 차이, 쓰임 **
- hashSet은 순서를 유지 하지 않는 데이터의 집합으로 객체 그 자체를 저장하며 map과 달리 중복을 허용하지 않습니다.
- hashmap은 hashtable과 유사한 자료구조로 key-value 쌍 형태로 데이터를 저장하고 중복 key 값을 허용하지 않지만 value는 허용합니다. null 입력 가능
- hashtable은 key-value로 데이터를 저장하는 자료구조로 HashMap과 반대로 동기화가 이루어진다. null 입력 불가능

## 21. 추상클래스, 인터페이스, 굳이 왜 추상클래스를 쓰는지
- 추상클래스는 추상 메서드를 선언하여 상속을 통해 자손 클래스에서 완성을 유도하는 클래스라 미완성 설계도라 표현하고 상속을 위한 클래스이기 때문에 객체를 생성할 수 없습니다.
- 인터페이스는 기본 설계도로 추상클래스와 다르게 다중 상속이 가능합니다.
- 추상 클래스와 인터페이스를 구분하는 이유는 추상 클래스는 is, 인터페이스는 ~을 할 수 있는
- 모든 클래스가 인터페이스를 사용해서 기본 틀을 구성한다면 공통으로 필요한 기능들도 오버라이딩하여 재정의해야하는 번거로움이 있습니다. 이렇게 공통된 기능이 필요하면 추상클래스를 이용하여 일반 메서드를 작성하여 자식 클래스에서 사용할 수 있도록 하면 됩니다.  
cf) 추상클래스는 상속 관계를 타고 올라갔을 때 같은 조상클래스를 상속하는데 기능까지 완벽하게 똑같은 경우 사용하고,  
인터페이스는 상속 관계를 타고 올라 갔을 때 다른 조상 클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스를 사용합니다.
https://myjamong.tistory.com/150
    추상클래스 1개 이상의 추상메서드를 가지고 있는 클래스로서
    인스턴스 생성이 불가능하며 추상클래스를 상속받은 하위클래스를 추상메서드를 구현해야한다.

    인터페이스
    인터페이스는 메서드를 정의할 때, 메서드의 바디가 존재하지않으며 인터페이스의 구현체는
    인터페이스에 정의된 모든 메서드를 구현해야한다. 

    추상클래스를 쓰는 이유는
    인터페이스의 경우 정의된 모든 메서드를 구현해야하므로
    불필요한 메서드까지 정의해야하는 단점이있다. 
    그래서 실무에서는 
    인터페이스를 선언후, 이를 구현하는 추상클래스에서 모든 메서드를 구현한뒤,
    추상클래스를 상속받는 하위클래스를 만들어 필요한 메서드만 사용하게 코드를 작성할 수 있따. 

## 22. 비동기식, 동기식 설명
- 동기식은 요청과 결과가 동시에 일어난다는 약속으로 요청한 자리에서 결과가 주어져야 합니다.
- 비동기식은 요청과 결과가 동시에 일어나지 않을거라는 약속입니다.
- 동기식은 설계가 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기 해야 한다는 단점이 있고 비동기식은 동기보단 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있습니다.

## 23. inner join과 outer join 차이
- inner join을 하면 A 와 B의 교집합을 얻을 수 있지만, Outer join을 하면 A와 B의 합집합을 얻을 수 있습니다.
그러므로 inner join은 조인 조건을 만족하는 행들만 포함시키고, outer join은 만족하는 값이 없는 행들도 얻을 수 있습니다.

## 24. <jsp:include>(액션태그) 와 <%@include %>(디렉티브) 차이
- include 디렉티브는 두 개의 JSP가 서블릿으로 변환하는 시점에 코드를 하나로 합친 다음 변환하기 때문에 코드레벨에서 코드 자체를 포함하는 방식이고,
- include 액션태그는 내부적으로 include되는 페이지로 흐름이 이동되었다가 포함되는 페이지의 처리가 끝나면 다시 흐름이 호출한 쪽으로 돌아오는 방식으로 동작합니다.
- <jsp:include> 액션태그 - 여러 페이지에 걸쳐 중복되는 화면을 하나의 JSP 페이지로 만들어 중복을 제거하는데 사용.
- <%@ include %> 디렉티브 - 여러 JSP 파일에 걸쳐 선언되어 사용되는 중복 변수나 중복 로직을 제거하는데 사용.

## 25. RuntimeException
- 실행 중에 발생하여 시스템 환경적으로나 input 값이 잘못된 경우 혹은 의도적으로 프로그래머가 잡아내기 위한 조건 등에 부합할 때 발생되게 만듭니다.

## 26. Servlet LifeCycle
- 1. 요청이 들어오면 Servlet 클래스가 로딩되어 요청에 대한 Servlet 객체가 생성된다.
- 2. 서버는 init()메소드를 호출해서 Servlet을 초기화한다.
- 3. service()메소드를 호출해서 Servlet이 브라우저의 요청을 처리하도록 한다
- 4. service() 메소드는 특정 HTTP요청(GET, POST)을 처리하는 메서드(doGet(), doPost()등)를 호출한다.
- 5. destory() 메소드를 호출하여 Servlet을 제거한다.

## 27. JSON(Javascript Object Notation)
- 데이터를 저장하거나 전송할 때 많이 사용되는 경량의 데이터 교환 형식
사람과 기계 모두 이해하기 쉽고 용량이 작아 XML을 대체해서 데이터 전송에 많이 사용됩니다.

## 28. 자바 변수
- 하나의 값을 저장할 수 있는 저장 공간입니다.

## 29. 클래스, 인스턴스, 지역변수
- 변수의 종류를 결정짓는 것은 변수가 선언된 위치입니다.
- 클래스 변수는 클래스 영역에 위치하며 클래스가 메모리에 올라갈 때 생성되며 스테틱 변수라고도 합니다.
- 인스턴스 변수는 클래스 영역에 위치하며 인스턴스가 생성될 때 생성됩니다.
- 지역 변수는 클래스 이외의 영역(메서드, 생성자, 초기화블록)에 위치하며 변수 선언문이 수행될 때 생성됩니다.
    - 인스턴스 변수 인스턴스 변수는 인스턴스가 생성될 때 생성됩니다. 그렇기 때문에 인스턴스 변수의 값을 읽어오거나 저장하려면 인스턴스를 먼저 생성해야합니다. 인스턴스 별로 다른 값을 가질 수 있으므로, 각각의 인스턴스마다 고유의 값을 가져야할 때는 인스턴스 변수로 선언합니다.
    - 클래스 변수  클래스 변수는 인스턴스 변수에 static만 붙여주면 됩니다. 인스턴스 변수는 각각 고유한 값을 가지지만 클래스 변수는 모든 인스턴스가 공통된 값을 공유하게 됩니다. 한 클래스의 모든 인스턴스들이 공통적인 값을 가져야할 때 클래스 변수로 선언합니다. 클래스가 로딩될 때 생성되어(그러므로 메모리에 딱 한번만 올라갑니다.) 종료 될 때 까지 유지되는 클래스 변수는 public 을 붙이면 같은 프로그램 내에서 어디서든 접근할 수 있는 전역 변수가 됩니다. 또한 인스턴스 변수의 접근법과 다르게 인스턴스를 생성하지 않고 클래스이름.클래스변수명 을 통해서 접근할 수 있습니다.
    - 지역 변수 메서드 내에서 선언되며 메서드 내에서만 사용할 수 있는 변수입니다. 메서드가 실행될 때 메모리를 할당 받으며 메서드가 끝나면 소멸되어 사용할 수 없게 됩니다.


## 30. 배열 리스트

## 31. 메서드 오버로딩, 오버라이딩

## 32. 객체지향의 개념

## 33. 추상 상속 다형성

## 34. 추상 클래스와 인터페이스의 차이

## 35. 이너클래스

## 36. 형변환

## 37. mvc

## 38. aop

## 39.


